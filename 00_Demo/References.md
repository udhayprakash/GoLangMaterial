## Fields of Usage

    - API/RPC services (returning non-HTML)
    - CLI Tools
    - Web services (returning HTML)
    - Data processing (pipeline, aggregation, ..)
    - Network Servers
    - Mobile Applications
    - Machine Learning
    - Image Processing
    - Load Balancers
    - System Admin
    - Hardware
    - Scripts
    - Crypto

## Popular software created with Go

- Docker
- Kubernates
- openstack

## Companies Using Go:

    http://go-lang.cat-v.org/organizations-using-go

## Execution flow:

    hello.go ==> compiler ==> Executable file ==> Executes on system

Stackoverflow Survey results
https://insights.stackoverflow.com/survey/2019#technology

## go commands

    go build    - compiles source code files into binaray files
    go clean    - To delete all the created executables in the current directory
    go doc      - For displaying documentation about the libraries
    go env      - print Go environment information
    go fmt      - reformats source files using Go standard formatting
    go get      - For retrieving and installing remote packages
    go install  - To install the executable
    go list     - list packages
    go run      - compiles and runs a program, without saving an executable file
    go test     - For unit testing and micro-benchmarks
    go version  - Displays the current Go version
    go vet      - Static Analyzer looking for potential errors in code
    go generate - Standard way to invoke code generators
    go rename   - For renaming variables, functions and so on in a type-safe way
    go fix      - upgrade code from an old version before go1 to a new version after go1

Ref: For editor/IDE settings to auto-format on save
https://blog.golang.org/go-fmt-your-code.

For the editor/IDE to automatically manage the addition or deletion of imports
based on usage,
go get -u golang.org/x/tools/cmd/goimports

To get the platforms supported by Go,
go tool dist list

## go formatting

    go fmt main.go : Prints the formatted source code of main.go file on the console.
    go fmt -w main.go: Writes the formatted code in the file main.go
    go fmt -w Tasks: Runs gofmt on all the files in the folder Tasks.

## go documentation

    1. Web based

        godoc -http=:6060 -v

    2. Command-line

        godoc <PACKAGE NAME>
        godoc net/http

## go build

    go build <SCRIPT.GO>
    go build <DIRECTORY WITH GO FILES>

    go build main.go
    go build TasksDir  // parses all .go files, except *_test.go files

    -o flag to change name of binary
    go build -o tasks

### Build time

    - By default, go build builds the entire application and the depending libraries, into a static binary and later throws all away.
    - This results in rebuilding everything every single time go build is executed.
    - For caching the library builds, use go install first and go build later.

## Cross Compilation

    env GOOS=darwin GOARCH=386 go build -o tasks.app
    env GOOS=windows GOARCH=386 go build -o tasks.exe

## go run

    - combines building and running the application in one command.
    - It generates a binary in the temp folder and executes it.
    - The binary file isnâ€™t retained after the run.

## go clean

    - will delete all files created by compiler, including:
        _obj/           - old directory of object, left by Makefiles
        _test/          - old directory of test, left by Makefiles
        _testmain.go    - old directory of gotest, left by Makefiles
        test.out        - old directory of test, left by Makefiles
        build.out       - old directory of test, left by Makefiles
        *.[568ao]       - object files, left by Makefiles
        DIR(.exe)       - generated by go build
        DIR.test(.exe)  - generated by go test -c
        MAINFILE(.exe)  - generated by go build MAINFILE.go

https://devdocs.io/go/
https://pkg.go.dev/

# Importance of GoLang 
- A containerized Golang API runs beautiflly on Amazon ECS. 
- Goroutines have growable segmented stacks. That means they will use more memory only when needed. 
- Goroutines have a faster startup time than threads. 
- Goroutines come with built-in primitives to communicate safely between themselves (channels).
- Goroutines allow you to avoid having to resort to mutex locking when sharing data structures. 
- Goroutines and OS threads do not have 1:1 mapping. A single goroutine can run on multiple threads. Goroutines are multiplexed into small number of OS threads. 
